// Generated by CoffeeScript 1.3.3

/*

Copyright (c) 2011-2012  Voicious

This program is free software: you can redistribute it and/or modify it under the terms of the
GNU Affero General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License along with this
program. If not, see <http://www.gnu.org/licenses/>.
*/


(function() {
  var RouteHandler, config, error, fileserve, jade, logger;

  fileserve = require('./modules/node-static');

  jade = require('./render');

  config = require('./config');

  error = require('./errorHandler');

  logger = (require('./logger')).get('voicious');

  RouteHandler = {
    _fileserver: new fileserve.Server(),
    _routes: config.PATH_ROUTES,
    resolve: function(request, response, requestObject) {
      var _this = this;
      if (requestObject.path[0] != null) {
        if (requestObject.path[0] === "/") {
          return {
            template: jade.Renderer.jadeRender('home.jade', {
              name: "Voicious"
            })
          };
        }
        if (requestObject.path[0] === config.STATIC_FILES_PATH) {
          return request.addListener('end', function() {
            return _this._fileserver.serve(request, response, function(e, res) {
              if ((e != null) && e.status === 404) {
                response.writeHead(e.status, e.headers);
                return response.end();
              }
            });
          });
        } else {
          return this.checkServiceRoute(requestObject);
        }
      }
    },
    checkServiceRoute: function(requestObject) {
      var handler, key, method, moduleExist, object, path, _ref;
      moduleExist = false;
      _ref = this._routes;
      for (key in _ref) {
        path = _ref[key];
        if (path === requestObject.path[0]) {
          moduleExist = true;
          break;
        }
      }
      if (moduleExist === true) {
        if (requestObject.path[1] != null) {
          object = requestObject.path[0];
          method = requestObject.path[1];
          logger.info("Calling class method \"" + method + "\" of object " + object);
          return this.callServiceFunction(object, method, requestObject);
        } else {
          object = requestObject.path[0];
          logger.info("Calling default class method of object " + object);
          return this.callServiceFunction(object, "default", requestObject);
        }
      } else {
        handler = new error.ErrorHandler;
        throw handler.throwError("[Error] : " + (requestObject.path.join('/')) + " is undefined", 404);
      }
    },
    callServiceFunction: function(object, method, requestObject) {
      var callingObject, func, funcName, funcValue, handler, i, k, methodExist, paramName, params, parent, v, value, _ref;
      methodExist = false;
      callingObject = require("." + config.SERVICES_PATH + ("" + object));
      for (parent in callingObject) {
        value = callingObject[parent];
        for (funcName in value) {
          funcValue = value[funcName];
          if (!(funcName === method)) {
            continue;
          }
          func = funcValue.toString();
          paramName = func.slice(func.indexOf('(') + 1, func.indexOf(')')).match(/([^\s,]+)/g);
          params = [];
          i = 0;
          _ref = requestObject.args;
          for (k in _ref) {
            v = _ref[k];
            if (paramName != null) {
              if (!(paramName[i] != null) || k !== paramName[i]) {
                handler = new error.ErrorHandler;
                throw handler.throwError("[Error] : unknown parameter \"" + k + "\" in function \"" + method + "\" ", 400);
              }
            }
            params.push(v);
            i++;
          }
          callingObject[parent][funcName].apply(null, params);
          methodExist = true;
          break;
        }
      }
      if (methodExist === false) {
        handler = new error.ErrorHandler;
        throw handler.throwError("[Error] : method \"" + method + "\" of class \"" + parent + "\" is undefined", 404);
      }
    }
  };

  exports.RouteHandler = RouteHandler;

}).call(this);
